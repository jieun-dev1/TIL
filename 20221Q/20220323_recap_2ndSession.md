
질문:  

java8 - permanent 영역이 없어진 이유? out of memory 가 잘 떠서 바뀌었다. 유추의 영역도 있긴 함. 개발자들이 계속 옵션 지정해야하는데
heap 은 시스템의 메모리 영역 크기에 준함. heap 은 jvm 의 꽤 큰 영역을 쓰고 있다. out of memory 가 발생할 가능성이 줄어서 없어졌다. 
없어졌다면, 없어진 이유도 생각해보자. 

jvm?
jdk jre jvm 도 같이 패키지로 받게 되어 있었어요. 
왜 os 별로 jdk 가 다를까? jdk 는 환경 별로 받을까요. jvm 에 대해서 jit compiler. 
jre 는 뭐고 jvm 은 뭔지? jdk 는 뭔지? 정의와 관계. 보완해보기. 
jdk: 어디든지 개발을 할 수 있음(어느 os에서든) byte 코드 변환해서 다른 곳으로 보낼 수 있음
실행 환경은 각각마다 달라야 함. 그런 의미에서 os 종속적이라고 하는 것.
jdk,jre, jvm 이 하는 일을 각각 알아보자.

jvm: 한글 아티클도 찾아서 주실 것.

자바 8: 익명 클래스 대체하는 람다 표현식이 등장함. 
람다 표현식으로 만들 수 있는 익명클래스는 람다 표현식으로 만드는 게 좋다. 가독성이 올라간다. 

자바의 단점?

1) 보일러 플레이트 코드가 많다. (getter, setter다 만들어야 한다. 규약이기도 하고)

대체: 롬복 라이브러리. 롬복은 어떤 동작을 지원.
보일러 코드를 컴파일 타임에 자동 생성해준다.
객체 @getter, @data 등.. @allargs 등등.

어떻게 만들어져요?
롬복 만들고, annotatoin processor, handler 도롬복이 만들어놔요.컴파일러 자바 프로그램 컴파일 시.
어노테이션 프로세싱 (컴파일 이전) 어노테이션에 맞는 프로세스 찾음. 프로세서가 어노테이션 handler 로 넘겨줌. handler 가 ast 를 받음. 거기에 여러 symbol 을 추가함.
그 symbol들 컴파일 되면, 코드가 생성이 됨.

*짧게는: 어노테이션 추가해놓은 걸 컴파일 시점에 결과물에 (바이트코드에 조작)해서 새로운 메서드를 만들어 냄.(여기까지만 하면 됨)
(reflection) 개념 연관지어서 조사해보면 좋겠습니다. 

Boxing vs Unboxing. 

최적화가 없다고 가정할 때. 타입이 바뀌는 것임. 메모리에 값이 있으면 바뀌어서 
for 문 안에서 하면 성능이 안좋음. unboxing 하고 boxing 할 떄. 최적화
굳이 boxing/unboxing 할 필요 없을 때 하면 성능이 안좋을 수 있다.(아티클 주실 것)

https://programmers.co.kr/learn/challenges
(챕터별로 해시/스택/큐는 다 풀고 그 다음 문제는 4문제 중에 2문제 정도는 푸록..)