#피드백 (Feedback)

-어떻게 엔지니어로 전향/ 개발자 하게 되었나요?
-TIL Github을 통해서 appeal 하기

-비개발 경력 많음
-바로 다음에 Tech Project 가 나오게 하기
-기타 활동 (한영 번역은 나중쪽에) 

제목에서 부터 기능 구현 다음에 트러블 슈팅이라는 칸을 넣기 (직접적으로. 읽지 않아도 한 줄 제목으로 볼 수 있게. 다 읽기 어렵기 때문에. 기술적으로 녹여낼 것을 앞에 쓰자) 
->a프로젝트 b문제를 겪었고 c. 

#
Heroku 서버 배포 에러를 해결하다. 
문법 오류를 쓰신 것 같음. 
포트폴리오에는 좀 더 어필할 만한 스토리가 있을까?
예: (GitActions - ci/cd. ci 에 여러 툴이 있음. github 안의 action 중에 gitACtions )
기술 선택 이유: 트러블 슈팅이 없으면 기술 선택 고민 / db 를 고민해서 b를 이런 이유로 선택했다. 등등.  
얼마나 조사하고 적용했는지. 잘못된 선택을 했을 때. -- 한게 아쉬웠다..
읽었을 떄 눈에 담기게 써보자. 

-아키텍처: 다이어그램 추가하면 좋겠다. 오늘 뭐먹지 기간 수정하기 (보통 pdf 니까 그림을 보내도 상관없다) 

-DB 설계는 어떻게 했는가?  이슈로 채우기 어렵다면. ERD 까지 그릴 필욘 없지만. 

kakao 사례. 다음번에는 조금 더 쉽게 설명해보자 
ex. SPRING SECURITY 기술스펙 충족시켰다보니 
-이런 선택과 충돌했다. (충분히 고민하고 설계했는데 )
-이렇게 만들었다. 

수정 후 다시 얘기해보기. 
시행착오 있었고 이런 a,b,c,d 도 해보고 이런 것도 공부해서 이런 프로젝트도 해봤어. 라고 긍정적으로 어떻게 어필할까? 


#다른 피드백

-정량적으로 써도 좋을 것 같다.

#현업에서 좋아하는 포인트 

-견고한 코드 작성 능력을 어떻게 견고함을 서포트하지? (test coverage 7-80%는 항상 챙겼다). 정량적인 증거를 대보자. 
-프로젝트 후 리팩토링을 반복적으로 해왔다 
-패턴에 대한 고민. 
-기술에 대한 깊은 공부. 
-좋은 코드 -> PUSH. TEST 코드가 깨지지 않고 정상적으로 BUILD 되는지. TEST Coverage.

질문:  

java8 - permanent 영역이 없어진 이유? out of memory 가 잘 떠서 바뀌었다. 유추의 영역도 있긴 함. 개발자들이 계속 옵션 지정해야하는데
heap 은 시스템의 메모리 영역 크기에 준함. heap 은 jvm 의 꽤 큰 영역을 쓰고 있다. out of memory 가 발생할 가능성이 줄어서 없어졌다. 
없어졌다면, 없어진 이유도 생각해보자. 

jvm?
jdk jre jvm 도 같이 패키지로 받게 되어 있었어요. 
왜 os 별로 jdk 가 다를까? jdk 는 환경 별로 받을까요. jvm 에 대해서 jit compiler. 
jre 는 뭐고 jvm 은 뭔지? jdk 는 뭔지? 정의와 관계. 보완해보기. 
jdk: 어디든지 개발을 할 수 있음(어느 os에서든) byte 코드 변환해서 다른 곳으로 보낼 수 있음
실행 환경은 각각마다 달라야 함. 그런 의미에서 os 종속적이라고 하는 것.
jdk,jre, jvm 이 하는 일을 각각 알아보자.

jvm: 한글 아티클도 찾아서 주실 것.

자바 8: 익명 클래스 대체하는 람다 표현식이 등장함. 
람다 표현식으로 만들 수 있는 익명클래스는 람다 표현식으로 만드는 게 좋다. 가독성이 올라간다. 

자바의 단점?

1) 보일러 플레이트 코드가 많다. (getter, setter다 만들어야 한다. 규약이기도 하고)

대체: 롬복 라이브러리. 롬복은 어떤 동작을 지원.
보일러 코드를 컴파일 타임에 자동 생성해준다.
객체 @getter, @data 등.. @allargs 등등.

어떻게 만들어져요?
롬복 만들고, annotatoin processor, handler 도롬복이 만들어놔요.컴파일러 자바 프로그램 컴파일 시.
어노테이션 프로세싱 (컴파일 이전) 어노테이션에 맞는 프로세스 찾음. 프로세서가 어노테이션 handler 로 넘겨줌. handler 가 ast 를 받음. 거기에 여러 symbol 을 추가함.
그 symbol들 컴파일 되면, 코드가 생성이 됨.

*짧게는: 어노테이션 추가해놓은 걸 컴파일 시점에 결과물에 (바이트코드에 조작)해서 새로운 메서드를 만들어 냄.(여기까지만 하면 됨)
(reflection) 개념 연관지어서 조사해보면 좋겠습니다. 

Boxing vs Unboxing. 

최적화가 없다고 가정할 때. 타입이 바뀌는 것임. 메모리에 값이 있으면 바뀌어서 
for 문 안에서 하면 성능이 안좋음. unboxing 하고 boxing 할 떄. 최적화
굳이 boxing/unboxing 할 필요 없을 때 하면 성능이 안좋을 수 있다.(아티클 주실 것)

https://programmers.co.kr/learn/challenges
(챕터별로 해시/스택/큐는 다 풀고 그 다음 문제는 4문제 중에 2문제 정도는 푸록..)