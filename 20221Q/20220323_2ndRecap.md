java8 - permanent 영역이 없어진 이유?

왜 OS 별로 JDK 가 다를까?

jdk jre jvm 도 같이 패키지로 받게 되어 있었어요.
왜 os 별로 jdk 가 다를까? jdk 는 환경 별로 받을까요. jvm 에 대해서 jit compiler.
jre 는 뭐고 jvm 은 뭔지? jdk 는 뭔지? 정의와 관계. 보완해보기.
jdk: 어디든지 개발을 할 수 있음(어느 os에서든) byte 코드 변환해서 다른 곳으로 보낼 수 있음
실행 환경은 각각마다 달라야 함. 그런 의미에서 os 종속적이라고 하는 것.
jdk,jre, jvm 이 하는 일을 각각 알아보자.

jvm: 한글 아티클도 찾아서 주실 것.

자바 8: 익명 클래스 대체하는 람다 표현식이 등장함.
람다 표현식으로 만들 수 있는 익명클래스는 람다 표현식으로 만드는 게 좋다. 가독성이 올라간다.

자바의 단점?
1) 보일러 플레이트 코드가 많다. (getter, setter다 만들어야 한다. 규약이기도 하고)

롬복의 작동 원리?
롬복은 보일러 코드를 컴파일 타임에 자동 생성해준다. 어노테이션이 있으면, 컴파일 시점에 결과물의 바이트코드를 조작해서 새로운 메서드를 만들어낸다.
Reflection 을 여기서 어떻게 연관지을 수 있을까?
대체: 롬복 라이브러리. 롬복은 보일러 코드를 컴파일 타임에 자동 생성해준다.
객

롬복 만들고, annotatoin processor, handler 도롬복이 만들어놔요.컴파일러 자바 프로그램 컴파일 시.
어노테이션 프로세싱 (컴파일 이전) 어노테이션에 맞는 프로세스 찾음. 프로세서가 어노테이션 handler 로 넘겨줌. handler 가 ast 를 받음. 거기에 여러 symbol 을 추가함.
그 symbol들 컴파일 되면, 코드가 생성이 됨.


Boxing vs Unboxing.

Boxing: 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환.
Unboxing: 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정.


최적화가 없다고 가정할 때. 타입이 바뀌는 것임. 메모리에 값이 있으면 바뀌어서
for 문 안에서 하면 성능이 안좋음. unboxing 하고 boxing 할 떄. 최적화
굳이 boxing/unboxing 할 필요 없을 때 하면 성능이 안좋을 수 있다.(아티클 주실 것)


Q1. Primitive Type과 Wrapper Type의 차이는 무엇일까요?
Q2. GC란 무엇인가요?
Q3. G1GC에 대해서 아시나요?
Q4. ArrayList, LinkedList의 차이는 무엇일까요?
Q5. 버전과 관련해서 LTS란 무엇인가요? 자바의 LTS는 무엇무엇이 있나요?

