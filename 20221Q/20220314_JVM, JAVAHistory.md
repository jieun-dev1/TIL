1. 
자바 설치 시, JDK 와 JRE 로 분리된다. jre 는 실행만을 위한 환경이다 (JavaAPI 와 JVM 포함)
JRE에는 JAVAC 등 자바를 컴파일하는 프로그램은 포함되어 있지 않다. 


2. JIT 컴파일러. (JVM 내부에 존재)
JIT(Just In Time) 어떤 메소드의 일부 혹은 전체 코드를 기계어로 변환하여 JVM 에서 번역하지 않도록 함으로써 보다 빠른 성능을 제공함. 
자바, .NET 등이 JIT을 사용한다. JIT 는 동적 변환이다. 프로그램 실행을 빠르게 하기 위해서 만들어졌다. 
명칭은 컴파일러이지만, 실행시에 적용된다.
기계어로의 변환은 코드가 실행되는 과정(런타임)에 실시간으로 일어나서(Just In Time), 전체 코드의 필요한 부분만 변환한다. 


프로그램을 실행하는 방식에는 
(1) 인터 프리터 방식 - 프로그램 실행할 때마다, 기계어(컴퓨터가 알아듣는 언어) 변환. 성능 매우 느림.
(2) STATIC 컴파일 방식이 있다. 실행하기 전에 기계어 변환하는 작업을 미리함. 변환작업은 한 번만 한다.

JIT 은 1,2의 혼합이다. 기계어 변환 작업은 인터프리터에 의해 지속적으로 수행하지만, 필요한 코드(컴파일 된 코드)는 캐시(메모리)에 담아두었다가 재사용함. 
실행 시점에서 인터프리트 방식으로 기계어 코드를 변환 하면서 그 코드를 캐싱해서, 같은 함수가 여러번 불릴 때 매번 기계어 코드 생성하는 것을 방지함. 

자바의 컴파일 방식 
javac 명령어를 수행하면, 자바 컴파일러가 프로그램 코드를 BYTE 코드로 변환 (class 파일이 만들어진다.) 
이렇게 컴파일한 코드는 리눅스, 맥, 윈도우 등에서 모두 사용 가능하다.(moto: compile once, run anywhere)
여기서 컴퓨터가 이해할 수 있도록 다시 변환하는 게 필요하다 (byte 코드는 기계어가 아니기 때문에 os 에서 바로 실행되지 않는다. 단 jvm은 실행시킬 수 있는 상태)
실제 바이트 코드를 실행하는 시점에서, jvm이 jit 컴파일러를 통해서 기계어로 변환한다.

*c는 리눅스, 윈도, 맥 등 운영체제 별로 운영체제 위에서 바로 실행되지만, 자바는 운영 체제 위의 JVM 에서 실행
![img_7.png](img/img_7.png)

자바는 운영체제에 독립적이다. 
C는 플랫폼에 따라 코드 및 실행 파일이 다르기 때문에, 플랫폼이 달라지면 컴파일을 새로 해야한다.
자바는 개발 및 실행 환경에 종속되지 않고 실행할 수 있다. 

https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC

자바는 플랫폼에 종속적이지 않다 (JVM 에서 Interpreter를 사용하기 때문에)
반면 JVM 은 플랫폼에 종속적이다 (자바로 작성된 프로그램을 특정 os에 맞게 기계어로 변경해줘야 하기 때문에)
자바의 역사: 다양한 디지털 기기에서 사용하려고 만듦. 기능은 똑같은데 하드웨어 구조가 다르다고 컴파일러를 일일이 만들어주는 건 번거로우니까, jvm이 만들어짐. 
jvm 가상머신이 있으면, 한 번의 컴파일 만으로도 어디서든 읽고 실행 가능함. 
다른 환경의 OS 나 CPU 구조와 상관 없이, 해당 OS 에 맞는 jvm 을 인스톨하는 과정만 하면, 
다른 환경의 Byte 코드를 언제든지 읽어올 수 있음. (출처: https://yeon-kr.tistory.com/118)
반면 c 는 다른 환경의 os 구조를 사용하는 환경에서는, 특정 os/cpu 구조를 사용하는 컴파일러에서 컴파일된 기계어를 읽을 수 없음. 

https://techvu.dev/113 (jvm 구조, 실행 과정 참고)
https://velog.io/@outgrow0905

3.JVM이란

자바 가상 머신: 작성한 자바 프로그램이 수행되는 프로세스.
java 라는 명령어를 통해서 애플리케이션이 수행되면, JVM 위에서 애플리케이션이 동작함. 
JVM은 작성한 프로그램을 찾고 실행함 + 자바 메모리 관리도 해줌. 
JVM은 자바언어를 모르고, Binary(class file format - byte code)만 이해한다. 


JVM의 구성
![JVMORACLE.PNG](img/JVMORACLE.PNG)

(1)ClassLoader

.java 소스를 컴파일하면 .class 파일(바이트 코드 생성)
이렇게 생성된 class 파일을 엮어서, 할당받은 메모리 영역인 RUntime data area 로 적재함. (자바 앱이 실행 중일때 이런 작업이 수행됨)

(2) Execution Engine

class Loader 에 의해 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해서 명령어 단위로 실행하는 역할. 
인터프리터, JIT 컴파일러 방식이 있다. 원래는 한 줄 한 줄 읽어서 해석하다보니, 느렸지만 JIT Compiler 방식에서 캐싱을 활용하면서 효율성 증가. 

(3) Garbage Collector

hEAP 메모리 영역에 생성된 객체 중 참조되지 않는 객체(해당 객체를 참조하는 변수가 없으면, 즉 더 이상 사용되지 않으면) 탐색 후 제거한다. 
GC 역할을 하는 시간이 정확히 언제인지는 알 수 없음. GC 수행하는 동안, GC 수행 쓰레드가 아닌 다른 모든 쓰레드는 일시정지됨. 

(4) Runtime Data Area

JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 영역. 자바 애플리케이션 실행 시 사용하는 데이터를 적재함.
Heap과 메서드는 JVM 이 시작될 때, 생성된다. 

Method area:
- 메소드 영역에서 자바 프로그램의 클래스 코드, 변수 코드, static, final 변수 등이 생성된다.

heap area:
- new 키워드로 생성한 객체가 저장되는 영역
- 동적으로 생성된 객체와 배열이 저장되는 곳으로(?) Garbage Collection의 대상이 되는 영역이다.
- Heap은 동적인 메모리 영역이다. 
- 
stack area:
- 지역 변수, 파라미터 등이 생성되는 영역, 동적으로 객체를 생성하면 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장된다.
- Stack은 스레드별로 독자적으로 가진다.
- Heap에 있는 객체가 Stack에서 참조 할 수 없는 경우 (stack 에서 가리키는 객체가 변경되었다던지) GC의 대상이 된다.


PC Register: 

현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있다.(CPU의 PC Register와 다르다.)

Native Method Stack: 

- 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역

*힙 영역이 중요한 이유: gc의 주요 대상이기 때문이다.

*Garvage Collector: 메모리 해제 작업을 하는 C와 달리, JVM 내에서 메모리 관리를 해줌 (Garbage Collection: jvm 힙 영역에서 사용하지 않는 객체를 삭제하는 프로세스)
Java7부터는 공식적으로 사용할 수 있는 G1 (Garvage 1st)라는 가비지 컬렉터를 제외한 나머지 jvm 은 다음과 같이 영역을 나누어 힙이라는 공간에 객체들을 관리한다. 


##GC 

GC 는 어떻게 동작하는가? 
영상 참고: https://www.youtube.com/watch?v=Fe3TVCEJhzo

힙의 구성 

![img_6.png](img/img_6.png)

permanent 가 사라지면서 JVM 에서는 PERM 을 MetaSpace가 대체한다. 

- Young: 젊은 객체
  
(1) Eden: 객체가 여기에서 생성됨 저장됨 
  
(2) Survivor: Eden이 꽉 차면, 살아있는 객체만 Survivor로 복사됨 (minor GC) survivor 이 꽉 차면, 다른 survivor2 영역으로 객체가 복사됨. 
eden 영역에서 살아있는 객체들도 survivor2로 감. 이 과정에서 SURVIVOR 영역은 둘 중 한쪽만 사용되어야 함. 두 SURVIVOR 에 모두 데이터가 존재하거나 둘다 0이어서는 안됨. 
  -> MINOR, YOUNG GC 
age 가 1 증가한다. 

- Old: 늙은, 오래 살아있는 객체들은(AGE 가 AGE Threshold 에 도달하면) old 영역으로 이동함(promotion). 
- 지속적으로 이동하다가 old 영역이 꽉 차면 GC 발생. 이를 Major/full GC 라고 부름.
- Perm: 클래스, 메서드에 대한 정보를 보관함. 


GC 가 일어나는 과정에서 SURVIVOR 로 이동하지 않는 객체는 지워진다는 뜻일까? 둘중 한쪽만 사용되어야 한다는 말의 의미? 


추가 출처: https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC/

GC 는 언제 동작하는가?

-OS 로부터 할당받은 시스템의 메모리가 부족할 때

-관리하고 있는 힙에서 사용되는 메모리가 허용된 임계값 초과 시.

-프로그래머가 직접 gc 실행 시.

![img_8.png](img/img_8.png)


GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때, 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 된다. 
그래서 핫스팟 jvm 에서는 스레드 로컬 할당 버퍼를 사용한다. 
스레드 별 메모리 버퍼를 사용하면, 다른 스레드에 영향 주지 않는 메모리 할당 작업이 가능해져서 그런다. 

## 추가 질문 

"자바는 운영체제에는 독립적이지만, JVM 은 운영체제에 독립적이다."

oracle jdk 를 검색해서 설치해보려고 하면, 운영체제 별로 파일이 다르더라고요. 
제가 이해하기로는, 운영체제 별로 JVM 이 다르기 때문에, JDK 가 별도로 만들어져 있다. 인데 제대로 이해한것일까요?
참고로 아래의 개념에서 출발하다가 공부하게 되었습니다.
자바가 운영체제에 독립적인 이유: 컴파일 과정 중, JVM 에서 인터프리터로 해석해주기 때문에, 어떤 OS 든지 jvm 만 설치되어 있다면 문제없다.
반면 JVM 은 운영체제에 종속적이다: 자바로 작성된 프로그램을 인터프리터로 해석하는 과정은 특정 os 에 맞게 변경하는 과정이기 때문이다.


메모리에 load 하고 heap stack 등 메모리 영역을 할당하는 것은 OS이다.하지만 어떻게 JVM이 runtime area를 자바 프로그램에게 할당할 수 있을까?**

- 이유는 OS가 JVM에게 메모리 할당 권한을 주기 때문이다.따라서 OS위에서 메모리를 받아 실행되는 다른 프로그램들과 다르게 자바 애플리케이션의 경우 JVM에게 메모리를 할당받아 실행된다.
- 즉, 자바 애플리케이션은 OS가 아닌 JVM에 종속적이다. 자바는 어느 운영체제나 하드웨어에 상관없이 JVM만 있으면, 자바로 작성한 프로그램을 실행시킬 수 있다.


참고
자바의 신 19장
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Java/%5BJava%5D%20JVM.md
https://technote-mezza.tistory.com/72
https://cryptosalamander.tistory.com/4 (JRE, JDK, JVM )

