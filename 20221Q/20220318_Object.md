Object 는 모든 클래스의 부모 클래스다. 

자바는 아무 상속을 받지 않으면, java.lang.object 클래스를 확장한다. 
왜? Object 클래스에 있는 메소드들을 통해서 클래스의 기본적인 행동을 정의할 수 있다.
Object 의 메서드 (A)  객체 처리 메소드 (B) 쓰레드를 위한 메서드 

(1) toString(): Object 클래스에서 가장 많이 쓰임 
Object 클래스의 toString()
getClass.getName() + '@' + Integer.toHexString(HashCode())

(2) Equals
참고: 참조 자료형에서 == 연산자는 주소값을 비교한다 (기본 자료형에서는 값을 비교한다.) 그래서 Object클래스의 .equals()를 오버라이딩 해야한다. 
두 객체가 같은지가 아니라, 주소가 가리키는 값이 같은지 알기 위함이다.  
참고로, 비교 대상 객체에서 equals()를 오버라이드 하지 않으면, equals() 메서드는 hashcode() 값(객체의 주소위치값)을 비교한다.
서로 다른 객체는 위치가 다르니 객체가 다르다는 결과가 나온다.


```
public class Ex9 {
	public static void main(String[] args) {
		Value v1 = new Value(10);
		Value v2 = new Value(10);

		if (v1.equals(v2))
			System.out.println("v1과 v2는 같습니다");
		else
			System.out.println("v1과 v2는 다릅니다");
	}
}

class Value {
	int value;

	Value(int value) {
		this.value = value;
	}

	public boolean equals(Object obj) {
//			return this == obj; //주소 비교. 서로 다른 객체는 false
		// 참조 변수의 형 변환 전에는 반드시 instance Of 로 타입 확인
		if (!(obj instanceof Value))
			return false;
		Value v = (Value) obj; // obj를 value로 형 변환
		return this.value == v.value;
	}
}
```

(3) HashCode 메서드
객체의 메모리 주소를 int로 변환해서(16진수로) 리턴.
두 객체가 동일하다면, hashCode() 값은 무조건 동일해야 한다. 
equals() 메서드를 오버라이드 하면, hashCode()도 오버라이드 해서 동일한 결과가 나오도록 만들어야 함. 
equals()를 사용해서 비교한 결과가 true 라면, hashCode() 호출 시 동일한 int 를 리턴해야. 

-> 이러한 제약 때문에 해당 메서드들은 IDE 에서 자동 생성을 권장. 
equals 와 HashCode는 같이 재정의 해야한다. 왜? 
둘다 처음에는 주소를 가지고 작업하는 데-> equals() 가 iv 를 가지고 비교하도록 바꿨으니, 

![img_10.png](img_10.png)

HashCode: Hashmap 과 같은 자료구조. 들어온 키와 등록된 값이 같은지 비교. 

- HashMap구현체 들여다보신적이 있나요? 

Hashcode Equals의 관계. 둘이 같은건가? 구현체가 어떻게 되어 잇는지, 그 관계에 대해서 정리해보자. 
Equals()를 overriding할 때는, HashCode()도 Override 해야한다. 


