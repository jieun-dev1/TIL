
예외가 발생하여 catch 블록이 실행된다고 해서, try블록 내에 실행된 모든 문장이 무시되는 것은 아니다. 
위의 예제에서 예외는 intArray[5] 를 호출하는 순간 발생한다 checkVariable3() 의 intArray[5]. 
그렇기 때문에, int[] intArray = new int[5]; 는 문제 없이 실행된다. 
catch 에서 사용하는 변수는 try블록 앞에 선언되어야 한다. 

```
public class ExceptionVariable {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ExceptionVariable sample = new ExceptionVariable();
		sample.checkVariable3();
	}

	public void checkVariable() {
		int[] intArray = new int[5];
		try {
			System.out.println(intArray[5]);
		} catch (Exception e) {
			System.out.println(intArray.length);
		}
		System.out.println("this code must run");
	}

	// compile error example
	public void checkVariable2() {
		try {
			int[] intArray = new int[5];// try블록 내에 선언하면, catch 블록에서는 cannot find symbol
			System.out.println(intArray[5]);
		} catch (Exception e) {
			System.out.println(intArray.length);
		}
		System.out.println("this code must run");
	}

	// compile error example
	public void checkVariable3() {
		int[] intArray = null;
		try {
			intArray = new int[5];
			System.out.println(intArray[5]); 
		} catch (Exception e) {
			System.out.println(intArray.length);
		}
		System.out.println("this code must run3");
	}
}

```

finally는 try/catch 여부에 상관 없이 일어난다. 

```
public class FinallySample {
	public static void main(String args[]) {
		FinallySample sample = new FinallySample();
		sample.finallySample();
	}

	public void finallySample() {
		int[] intArray = new int[5];

		try {
			System.out.println(intArray[5]);
		} catch (Exception e) {
			System.out.println(intArray.length);
		} finally {
			System.out.println("Here is finally");
		}
		System.out.println("This code must run.");

	}

}

```