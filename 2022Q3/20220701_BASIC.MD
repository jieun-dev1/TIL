## 스프링 기본 


**빈을 생성할 때 private 으로 생성한다는 것의 의미?**

외부에서 접근하지 않고, 해당 클래스에서만 사용한다.

private 이란? (참고: [https://mozi.tistory.com/471](https://mozi.tistory.com/471))

멤버 변수가 private 일 때는 다른 클래스에서 접근할 수 없음.
보호하고 싶은 멤버에 private 을 붙여서 접근을 제한하는 것을 캡슐화라고 한다.
보통 변수는 private, 함수(메서드)는 public 으로 지정한다.
외부에서 값을 직접적으로 대입 시킬 수가 없고. 값을 대입하려면, public 메서드로 set 을 사용하는 방식으로 수정 가능하다.

프로젝트에서 짠 코드를 다시보면, 

*@Data 안에 @Setter 가 있다.

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    private Long id;
    private String loginId;
    private String email;

    public User(String loginId, String email) {
        this.loginId = loginId;
        this.email = email;
    }
}
```

이 User 객체를 가져다 쓸 때, set 메서드로 값을 수정하는 것이다. 

```
User user2 = new User();
user2.setId(2L);
user2.setLoginId("user2");
user2.setEmail("user2@gmail.com");
```

**@Autowired 와 생성자 주입의 차이?**

우선, 가급적 생성자 주입을 사용한다.
우선 @Autowired 는 스프링 Bean 객체만 사용이 가능하다.
(p.s.그래서 단위테스트에서는 @Autowired 안쓰고 스프링 통합 테스트 (스프링 프레임워크 쓰는) 경우에 @Autowired 를 쓴다. 
(테스트 코드이기 때문에 편하게 Autowired 를 많이 쓴다고 한다)
Autowired 를 하면, 스프링 컨테이너에서 알맞은 타입을 자동 주입해준다.
주입을 하려면 대상을 찾아야 하는데, 스프링 컨테이너에 이 대상이 들어 있어야 하기 때문.

private final 의 의미?

생성자 주입에서 final 키워드를 사용하는 건, 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.

수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다

**필드 vs 생성자 주입**

#생성자 주입을 해야 하는 이유
(1) 서버 구동 전에 순환참조 에러를 찾아줌. 필드주입은 메서드 호출 후에야 순환 참조 에러가 발생.
필드/수정자
-먼저 빈 생성 (ex jack)
-주입하려는 빈을 찾아서 주입 (ex.Coding)

생성자
-생성자의 인자에 사용되는 빈을 찾거나, 빈 팩토리에서 만듦
(ex. Jack 생성에 사용되는 Coding 빈을 찾음)
-찾은 인자 빈으로 주입하려는 빈의 생성자 호출
(jack 의 생성자 호출)
-이번에는 Coding 을 생성할 떄, jack 을 생성하려고 하면,
Coding 을 주입하려고 하면 이미 Coding 안에 jack 이 있기 때문에,
순환 참조가 문제가 됨.

(2) final 선언이 가능해서,
런타임에 객체 불변성을 보장함.
생성자 주입은 주입 시점에서 누락된 데이터를 잡아준다 (컴파일 시점에서 막아줌)
필드 주입은 생성이 된 다음에 주입이 되니까 final 을 쓸 수 없음. (나머지 주입 방식도 그렇다)

(3) 테스트 코드 작성이 용이함.
스프링 컨테이너 도움 없이 테스트 코드 더 편리하게 작성 가능.
-> 이 부분은 잘 모르겠다…

- 싱글톤 패턴을 구현하려면 private 생성자를 써야한다고 했는데, @AllArgsConstructor 등은 public 구현체인 것 같다. 그래도 될까?


    그렇다. 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
    
    스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
    이전에 설명한 컨테이너 생성 과정을 자세히 보자. 컨테이너는 객체를 하나만 생성해서 관리한다.
    스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다. 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
    싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
    DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다
    
    (그래서 프로젝트 코드를 보면 외부에서 new 를 사용할 수 있는 것이다)

출처: 김영한님 핵심원리, https://jackjeong.tistory.com/41


